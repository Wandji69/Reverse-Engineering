/*
  SSD1306 driver for the Raspberry Pi Pico C SDK
  ----------------------------------------------
  Re-designed from the C++ lib from https://github.com/blippy/rpi/tree/master/1306/pico-sdk
*/

#include <string.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"

const uint8_t ssd1306_font6x8[] =
{
  0x00, 0x06, 0x08, 0x20,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // sp
  0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,  // !
  0x00, 0x00, 0x07, 0x00, 0x07, 0x00,  // "
  0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,  // #
  0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,  // $
  0x00, 0x23, 0x13, 0x08, 0x64, 0x62,  // %
  0x00, 0x36, 0x49, 0x55, 0x22, 0x50,  // &
  0x00, 0x00, 0x05, 0x03, 0x00, 0x00,  // '
  0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,  // (
  0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,  // )
  0x00, 0x14, 0x08, 0x3e, 0x08, 0x14,  // *
  0x00, 0x08, 0x08, 0x3e, 0x08, 0x08,  // +
  0x00, 0x00, 0x00, 0xa0, 0x60, 0x00,  // ,
  0x00, 0x08, 0x08, 0x08, 0x08, 0x08,  // -
  0x00, 0x00, 0x60, 0x60, 0x00, 0x00,  // .
  0x00, 0x20, 0x10, 0x08, 0x04, 0x02,  // /
  0x00, 0x3e, 0x51, 0x49, 0x45, 0x3e,  // 0
  0x00, 0x00, 0x42, 0x7f, 0x40, 0x00,  // 1
  0x00, 0x42, 0x61, 0x51, 0x49, 0x46,  // 2
  0x00, 0x21, 0x41, 0x45, 0x4b, 0x31,  // 3
  0x00, 0x18, 0x14, 0x12, 0x7f, 0x10,  // 4
  0x00, 0x27, 0x45, 0x45, 0x45, 0x39,  // 5
  0x00, 0x3c, 0x4a, 0x49, 0x49, 0x30,  // 6
  0x00, 0x01, 0x71, 0x09, 0x05, 0x03,  // 7
  0x00, 0x36, 0x49, 0x49, 0x49, 0x36,  // 8
  0x00, 0x06, 0x49, 0x49, 0x29, 0x1e,  // 9
  0x00, 0x00, 0x36, 0x36, 0x00, 0x00,  // :
  0x00, 0x00, 0x56, 0x36, 0x00, 0x00,  // ;
  0x00, 0x08, 0x14, 0x22, 0x41, 0x00,  // <
  0x00, 0x14, 0x14, 0x14, 0x14, 0x14,  // =
  0x00, 0x00, 0x41, 0x22, 0x14, 0x08,  // >
  0x00, 0x02, 0x01, 0x51, 0x09, 0x06,  // ?
  0x00, 0x32, 0x49, 0x59, 0x51, 0x3e,  // @
  0x00, 0x7c, 0x12, 0x11, 0x12, 0x7c,  // A
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x36,  // B
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x22,  // C
  0x00, 0x7f, 0x41, 0x41, 0x22, 0x1c,  // D
  0x00, 0x7f, 0x49, 0x49, 0x49, 0x41,  // E
  0x00, 0x7f, 0x09, 0x09, 0x09, 0x01,  // F
  0x00, 0x3e, 0x41, 0x49, 0x49, 0x7a,  // G
  0x00, 0x7f, 0x08, 0x08, 0x08, 0x7f,  // H
  0x00, 0x00, 0x41, 0x7f, 0x41, 0x00,  // I
  0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,  // J
  0x00, 0x7f, 0x08, 0x14, 0x22, 0x41,  // K
  0x00, 0x7f, 0x40, 0x40, 0x40, 0x40,  // L
  0x00, 0x7f, 0x02, 0x0C, 0x02, 0x7f,  // M
  0x00, 0x7f, 0x04, 0x08, 0x10, 0x7f,  // N
  0x00, 0x3e, 0x41, 0x41, 0x41, 0x3e,  // O
  0x00, 0x7f, 0x09, 0x09, 0x09, 0x06,  // P
  0x00, 0x3e, 0x41, 0x51, 0x21, 0x5e,  // Q
  0x00, 0x7f, 0x09, 0x19, 0x29, 0x46,  // R
  0x00, 0x46, 0x49, 0x49, 0x49, 0x31,  // S
  0x00, 0x01, 0x01, 0x7f, 0x01, 0x01,  // T
  0x00, 0x3f, 0x40, 0x40, 0x40, 0x3f,  // U
  0x00, 0x1f, 0x20, 0x40, 0x20, 0x1f,  // V
  0x00, 0x3f, 0x40, 0x38, 0x40, 0x3f,  // W
  0x00, 0x63, 0x14, 0x08, 0x14, 0x63,  // X
  0x00, 0x07, 0x08, 0x70, 0x08, 0x07,  // Y
  0x00, 0x61, 0x51, 0x49, 0x45, 0x43,  // Z
  0x00, 0x00, 0x7f, 0x41, 0x41, 0x00,  // [
  0x00, 0x55, 0x2a, 0x55, 0x2a, 0x55,  // 55
  0x00, 0x00, 0x41, 0x41, 0x7f, 0x00,  // ]
  0x00, 0x04, 0x02, 0x01, 0x02, 0x04,  // ^
  0x00, 0x40, 0x40, 0x40, 0x40, 0x40,  // _
  0x00, 0x00, 0x01, 0x02, 0x04, 0x00,  // '
  0x00, 0x20, 0x54, 0x54, 0x54, 0x78,  // a
  0x00, 0x7f, 0x48, 0x44, 0x44, 0x38,  // b
  0x00, 0x38, 0x44, 0x44, 0x44, 0x20,  // c
  0x00, 0x38, 0x44, 0x44, 0x48, 0x7f,  // d
  0x00, 0x38, 0x54, 0x54, 0x54, 0x18,  // e
  0x00, 0x08, 0x7e, 0x09, 0x01, 0x02,  // f
  0x00, 0x18, 0xa4, 0xa4, 0xa4, 0x7c,  // g
  0x00, 0x7f, 0x08, 0x04, 0x04, 0x78,  // h
  0x00, 0x00, 0x44, 0x7d, 0x40, 0x00,  // i
  0x00, 0x40, 0x80, 0x84, 0x7d, 0x00,  // j
  0x00, 0x7f, 0x10, 0x28, 0x44, 0x00,  // k
  0x00, 0x00, 0x41, 0x7f, 0x40, 0x00,  // l
  0x00, 0x7c, 0x04, 0x18, 0x04, 0x78,  // m
  0x00, 0x7c, 0x08, 0x04, 0x04, 0x78,  // n
  0x00, 0x38, 0x44, 0x44, 0x44, 0x38,  // o
  0x00, 0xfc, 0x24, 0x24, 0x24, 0x18,  // p
  0x00, 0x18, 0x24, 0x24, 0x18, 0xfc,  // q
  0x00, 0x7c, 0x08, 0x04, 0x04, 0x08,  // r
  0x00, 0x48, 0x54, 0x54, 0x54, 0x20,  // s
  0x00, 0x04, 0x3f, 0x44, 0x40, 0x20,  // t
  0x00, 0x3c, 0x40, 0x40, 0x20, 0x7c,  // u
  0x00, 0x1c, 0x20, 0x40, 0x20, 0x1c,  // v
  0x00, 0x3c, 0x40, 0x30, 0x40, 0x3c,  // w
  0x00, 0x44, 0x28, 0x10, 0x28, 0x44,  // x
  0x00, 0x1c, 0xa0, 0xa0, 0xa0, 0x7c,  // y
  0x00, 0x44, 0x64, 0x54, 0x4c, 0x44,  // z
  0x00, 0x00, 0x08, 0x77, 0x00, 0x00,  // {
  0x00, 0x00, 0x00, 0x7f, 0x00, 0x00,  // |
  0x00, 0x00, 0x77, 0x08, 0x00, 0x00,  // }
  0x00, 0x10, 0x08, 0x10, 0x08, 0x00,  // ~
  0x14, 0x14, 0x14, 0x14, 0x14, 0x14,  // horiz lines, DEL
  0x00  // this byte is required for italic type of font
};

#define SET_CONTRAST 0x81
#define SET_ENTIRE_ON 0xa4
#define SET_NORM_INV 0xa6
#define SET_DISP 0xae
#define SET_MEM_ADDR 0x20
#define SET_COL_ADDR 0x21
#define SET_PAGE_ADDR 0x22
#define SET_DISP_START_LINE 0x40
#define SET_SEG_REMAP 0xa0
#define SET_MUX_RATIO 0xa8
#define SET_COM_OUT_DIR 0xc0
#define SET_DISP_OFFSET 0xd3
#define SET_COM_PIN_CFG 0xdA  // s10.1.18 page 40
#define SET_DISP_CLK_DIV 0xd5
#define SET_PRECHARGE 0xd9
#define SET_VCOM_DESEL 0xdb
#define SET_CHARGE_PUMP 0x8d

#define I2C_PORT i2c0
//#define OLED_128x32
/*
#ifdef OLED_128x32
const uint8_t height = 32;
#else
const uint8_t height = 64;
#endif
*/

static uint8_t height = 32;
const uint8_t SID = 0x3c ; // different height displays have different addr - 03d
const uint8_t width = 128;
int pages() { return height/8; }
uint8_t scr[1025]; // being: 8 pages (max) * 128 width + 1 I2C command byte

void write_cmd(uint8_t cmd);

void fill_scr(uint8_t v)
{
  memset(scr, v, sizeof(scr));
}

void send_data(uint8_t* data, int nbytes)
{
  i2c_write_blocking(I2C_PORT, SID, data, nbytes, false);
}

void send2(uint8_t v1, uint8_t v2)
{
  uint8_t buf[2];
  buf[0] = v1;
  buf[1] = v2;
  send_data(buf, 2);
}

void show_scr()
{
  write_cmd(SET_MEM_ADDR);  // 0x20
  write_cmd(0b01);  // vertical addressing mode
  write_cmd(SET_COL_ADDR);  // 0x21
  write_cmd(0);
  write_cmd(127);
  write_cmd(SET_PAGE_ADDR);  // 0x22
  write_cmd(0);
  write_cmd(pages()-1);
  scr[0] = 0x40;  // the data instruction 
  int size = pages()*width +1;
  send_data(scr, size);
}

void write_cmd(uint8_t cmd) 
{ 
  send2(0x80, cmd);
}

void power_off() { write_cmd(SET_DISP | 0x00); }

void power_on() { write_cmd(SET_DISP | 0x01); }

void contrast(uint8_t contrast) { write_cmd(SET_CONTRAST); write_cmd(contrast); }

void invert(uint8_t invert) { write_cmd(SET_NORM_INV | (invert & 1)); }

static void init_i2c()
{
  i2c_init(I2C_PORT, 100 * 1000);
  gpio_set_function(4, GPIO_FUNC_I2C);  // GPIO 4 (SDA)
  gpio_set_function(5, GPIO_FUNC_I2C);  // GPIO 5 (SCL)
  gpio_pull_up(4);
  gpio_pull_up(5);
}

void init_display(int h)
{
  init_i2c();
  height = h;
  static uint8_t cmds[] = 
  {
    SET_DISP | 0x00,  // display off 0x0e | 0x00
    SET_MEM_ADDR,  // 0x20
    0x00,  // horizontal
    SET_DISP_START_LINE | 0x00,  // 0x40
    SET_SEG_REMAP | 0x01,  // column addr 127 mapped to SEG0
    SET_COM_OUT_DIR | 0x08,  // scan from COM[N] to COM0  (0xC0 | val)
    SET_DISP_OFFSET,  // 0xd3
    0x00,
    SET_DISP_CLK_DIV,  // 0xd5
    0x80,
    SET_PRECHARGE,  // 0xd9
    0xF1,
    SET_VCOM_DESEL,  // 0xdb
    0x40,  // changed by mcarter
    SET_CONTRAST,  // 0x81
    0xFF,  // maximum
    SET_ENTIRE_ON,  // output follows RAM contents, 0xa4
    SET_NORM_INV,  // not inverted 0xa6
    SET_CHARGE_PUMP, // 0x8d
    0x14,
    SET_DISP | 0x01
  };
  for(int i=0; i<sizeof(cmds); i++)  // write all the commands
    write_cmd(cmds[i]);
  fill_scr(0);
  show_scr();
}

void draw_pixel(int16_t x, int16_t y, int color) 
{
  if(x<0 || x >= width || y<0 || y>= height) return;
  int page = y/8;
  int bit = 1<<(y % 8);
  int xincr = 8;
  xincr = height/8;
  uint8_t* ptr = scr + x*xincr + page  + 1; 
  switch (color) 
  {
    case 1:  // white
      *ptr |= bit;
      break;
    case 0:  // black
      *ptr &= ~bit;
      break;
    case -1:  // inverse
      *ptr ^= bit;
      break;
  }
}

void draw_bitmap(int16_t x, int16_t y, const uint8_t bitmap[], int16_t w,
  int16_t h, uint16_t color) 
{
  int16_t byte_width = (w + 7) / 8;  // bitmap scanline pad = whole byte
  uint8_t byte = 0;
  for (int16_t j = 0; j < h; j++, y++) 
  {
    for (int16_t i = 0; i < w; i++) 
    {
      if (i & 7)
        byte <<= 1;
      else
        byte = bitmap[j * byte_width + i / 8];
      if (byte & 0x80)
        draw_pixel(x + i, y, color);
    }
  }
}

void draw_letter_at(uint8_t x, uint8_t y, char c)
{
  if(c< ' ' || c>  0x7f) c = '?';  // 0x7F is the DEL key
  int offset = 4 + (c - ' ' )*6;
  for(int col = 0 ; col < 6; col++) 
  {
    uint8_t line =  ssd1306_font6x8[offset+col];
    for(int row =0; row <8; row++) 
    {
      draw_pixel(x+col, y+row, line & 1);
      line >>= 1;
    }
  }
  for(int row = 0; row<8; row++) 
  {
    draw_pixel(x+6, y+row, 0);
    draw_pixel(x+7, y+row, 0);
  }
}

static int cursor_x = 0, cursor_y = 0;
void ssd1306_print(const char* str)
{
  char c;
  while(c = *str) 
  {
    str++;
    if(c == '\n') 
    {
      cursor_x = 0;
      cursor_y += 8;
      continue;
    }
    draw_letter_at(cursor_x, cursor_y, c);
    cursor_x += 8;
  }
}

void set_cursor_x(int x)
{
  const int pos = 8;
  cursor_x = pos * x;
}

void set_cursor_y(int y)
{
  const int pos = 8;
  cursor_y = pos * y;
}

